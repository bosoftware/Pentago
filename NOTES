-- Split from min max to minmax on SMTree and evaluate
-- How game tree is traversable and that requires to generalise the type
(increases reuse)
-- How fmap . fmap . fmap can be seen as lifting

-- I am using PlayerWrapperMonad, maybe there is a simpler solution
     

   Functor (lift function)

-- PROFILING
  how inherited includes also the time 

  1. Show that the profiling time shows that leak happens:
    sequenceA increase in -hc
      This is under trivial! (after board is displayed)
    SYSTEM in -hr <-- some kind 
    BLACKHOLE in -hy <-- evaluating thunk (strengthened by

    seq on newPlayerstate forces the overflow!
    It must be generating the generator.

  2. Method:
    cabal configure --enable-executable-profiling
    ./Pentago +RTS -p -hc -cost centre memory
    ./Pentago +RTS -p -hr -retainer information (who holds it, image and prof))
    ./Pentago +RTS -p -hy


-- TODO mkStdGen return badly initialized struct
-- map (\i -> randomR (0,11) (mkStdGen i)) [0..100]


-- How this causes space leak
shuffle xs =
  let n = length xs
      indexes = [0..(n - 1)]
      xsArray = Data.Array.array (0, (n - 1)) (zip indexes xs)
  in do
    gen <- get
    let
      (orderList, newGen) = shuffle' indexes gen
      newXs = map (\i -> xs ! i) orderList
    put newGen
    return newXs
